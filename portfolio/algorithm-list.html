<!DOCTYPE html>
<html>

<head>
    <title>Samuel Berkun</title>
</head>
<body>
    
    
    <h1>Algorithm List</h1>
    <h3>In projects</h3>
    <ul>
      <li>Kruskal's algorithm - all the maze games</li>
      <li>Prim's algorithm - <a href="https://www.khanacademy.org/computer-programming/maze-generator/5214749789323264">Maze Generator</a></li>
      <li>Dead-end filling  - maze games 1 and 2</li>
      <li>Perspective projection - 3d maze</li>
    </ul>
    <h3>Java files: sorting algerithms</h3>
    <ul>
      <li>Iterative quicksort (using a helping boolean array)</li>
      <li>Selection sort</li>
      <li>Bubble sort</li>
      <li>In place, iterative merge sort - I came up with this algorithm when working on castle sort.</li>
      <li>An iterative version of dual-pivot quicksort</li>
      <li>Castle sort - an algorithm I came up with, and named. Unfortunately, it's pretty slow.</li>
      <li>Heap sort</li>
      <li>Quad mergesort - based on mergesort, but combines 4 sublists at a time. Iterative.</li>
      <li>Quicksort with three pivots - unfinished</li>  
    </ul>
    <h3>Java files: random algerithms</h3>
    <ul>
      <li>rotateLeft3: rotates an array left 3 indices, by testing every permutation of the array</li>
      <li>find_prime: finds the nth prime, when n is in [1,2000000]</li>
      <li>makeprimes: makes an array of prime numbers up to n</li>
      <li>primes_sum: sum of primes up to n</li>
      <li>add_digits: given two numbers represented as arrays of digits, add them and return an array of digits</li>
      <li>self_avoiding_walk: if there is an n*m array of points, 
          how many ways are there between opposite corners without going through a point twice. 
          <a href="https://oeis.org/wiki/Self-avoiding_walks">https://oeis.org/wiki/Self-avoiding_walks</a>
      </li>
    </ul>

        
    <script src="content.js"></script>

</body>
</html>
